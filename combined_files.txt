--- .//stellanow_sdk_python_demo/messages/store_receipt_message.py ---

"""
 This file is auto-generated by StellaNowCLI. DO NOT EDIT.

 ID: 06d014b9-9d56-4c08-a19a-5b5363187f00
 Generated: 2025-03-30T12:59:05Z
"""

from pydantic import Field

from stellanow_sdk_python.messages.message import Entity, StellaNowMessageBase

class StoreReceiptMessage(StellaNowMessageBase):
    transaction_id: str = Field(None, serialization_alias='transaction_id')

    def __init__(self, patron: str, local_shop: str, transaction_id: str):
        super().__init__(
            event_name="store_receipt",
            entities=[
                Entity(entityTypeDefinitionId="patron", entityId=patron),
                Entity(entityTypeDefinitionId="local_shop", entityId=local_shop)
            ],
            patron=patron,
            local_shop=local_shop,
            transaction_id=transaction_id
        )


"""
 Generated from:
{
    "createdAt": "2025-03-11 10:25:26",
    "updatedAt": "2025-03-11 10:25:31",
    "id": "06d014b9-9d56-4c08-a19a-5b5363187f00",
    "name": "store_receipt",
    "projectId": "4c9450e5-1a6e-4ab4-8b1d-43e9c2a40714",
    "isActive": true,
    "description": "",
    "fields": [
        {
            "id": "b049d17d-4f46-46de-92c8-b364ec0754df",
            "name": "transaction_id",
            "fieldType": {
                "value": "String"
            },
            "required": true,
            "subfields": []
        }
    ],
    "entities": [
        {
            "id": "5ed0f3c9-e3a1-417c-b0da-277d863d88f1",
            "name": "patron"
        },
        {
            "id": "7a4af14f-a75e-4ef2-a7cb-60cdb4979bdd",
            "name": "local_shop"
        }
    ]
}
"""
--- .//stellanow_sdk_python_demo/messages/user_details_message.py ---

"""
 This file is auto-generated by StellaNowCLI. DO NOT EDIT.

 ID: 3af70656-e95b-489d-ae2e-ebe7c0d011d6
 Generated: 2025-03-30T12:59:05Z
"""

from pydantic import Field

from stellanow_sdk_python.messages.message import Entity, StellaNowMessageBase
from models.phone_number_model import PhoneNumberModel


class UserDetailsMessage(StellaNowMessageBase):
    user_id: str = Field(None, serialization_alias='user_id')
    phone_number: PhoneNumberModel = Field(None, serialization_alias='phone_number')

    def __init__(self, patron: str, user_id: str, phone_number: PhoneNumberModel):
        super().__init__(
            event_name="user_details",
            entities=[
                Entity(entityTypeDefinitionId="patron", entityId=patron)
            ],
            patron=patron,
            user_id=user_id,
            phone_number=phone_number
        )


"""
 Generated from:
{
    "createdAt": "2025-02-28 00:27:00",
    "updatedAt": "2025-02-28 00:27:25",
    "id": "3af70656-e95b-489d-ae2e-ebe7c0d011d6",
    "name": "user_details",
    "projectId": "4c9450e5-1a6e-4ab4-8b1d-43e9c2a40714",
    "isActive": true,
    "description": "",
    "fields": [
        {
            "id": "057074db-eb36-4d63-bf1a-f9eff3c214ba",
            "name": "user_id",
            "fieldType": {
                "value": "String"
            },
            "required": true,
            "subfields": []
        },
        {
            "id": "5a2437a8-2dee-4cd2-8f7c-ab7b0db8f876",
            "name": "phone_number",
            "fieldType": {
                "value": "Model",
                "modelRef": "d3a72099-a3ff-453e-9628-9e8d7dba2714"
            },
            "required": false,
            "subfields": [
                {
                    "id": "a22de624-eb54-40ab-a868-3cf52160ce6e",
                    "name": "number",
                    "fieldType": {
                        "value": "Integer"
                    },
                    "required": true,
                    "path": [
                        "phone_number",
                        "number"
                    ],
                    "modelFieldId": "b1914044-74ef-4af4-8e40-0a4dd48ea5d0"
                },
                {
                    "id": "7eb6e628-182e-489b-aa03-9efb03360379",
                    "name": "country_code",
                    "fieldType": {
                        "value": "Integer"
                    },
                    "required": true,
                    "path": [
                        "phone_number",
                        "country_code"
                    ],
                    "modelFieldId": "20ed506e-0913-44db-ba4a-02f2529caec2"
                }
            ]
        }
    ],
    "entities": [
        {
            "id": "5ed0f3c9-e3a1-417c-b0da-277d863d88f1",
            "name": "patron"
        }
    ]
}
"""
--- .//stellanow_sdk_python_demo/messages/models/phone_number_model.py ---

"""
 This file is auto-generated by StellaNowCLI. DO NOT EDIT.

 ID: d3a72099-a3ff-453e-9628-9e8d7dba2714
 Generated: 2025-03-30T12:59:05Z
"""

from pydantic import Field
from stellanow_sdk_python.messages.message import StellaNowMessageBase


class PhoneNumberModel(StellaNowMessageBase):
    country_code: int = Field(None, serialization_alias='country_code')
    number: int = Field(None, serialization_alias='number')


"""
 Generated from:
{
    "createdAt": "2025-02-28 00:25:55",
    "updatedAt": "2025-02-28 00:25:55",
    "id": "d3a72099-a3ff-453e-9628-9e8d7dba2714",
    "name": "phone_number",
    "description": "",
    "fields": [
        {
            "id": "20ed506e-0913-44db-ba4a-02f2529caec2",
            "name": "country_code",
            "fieldType": {
                "value": "Integer"
            }
        },
        {
            "id": "b1914044-74ef-4af4-8e40-0a4dd48ea5d0",
            "name": "number",
            "fieldType": {
                "value": "Integer"
            }
        }
    ]
}
"""
--- .//stellanow_sdk_python_demo/messages/user_login_message.py ---

"""
 This file is auto-generated by StellaNowCLI. DO NOT EDIT.

 ID: 5b9f25e9-b173-4db1-ad12-c13a9983b70a
 Generated: 2025-03-30T12:59:05Z
"""

from datetime import datetime
from pydantic import Field

from stellanow_sdk_python.messages.message import Entity, StellaNowMessageBase

class UserLoginMessage(StellaNowMessageBase):
    user_id: str = Field(None, serialization_alias='user_id')
    timestamp: datetime = Field(None, serialization_alias='timestamp')

    def __init__(self, patron: str, user_id: str, timestamp: datetime):
        super().__init__(
            event_name="user_login",
            entities=[
                Entity(entityTypeDefinitionId="patron", entityId=patron)
            ],
            patron=patron,
            user_id=user_id,
            timestamp=timestamp
        )


"""
 Generated from:
{
    "createdAt": "2025-02-28 00:25:02",
    "updatedAt": "2025-02-28 00:27:21",
    "id": "5b9f25e9-b173-4db1-ad12-c13a9983b70a",
    "name": "user_login",
    "projectId": "4c9450e5-1a6e-4ab4-8b1d-43e9c2a40714",
    "isActive": true,
    "description": "",
    "fields": [
        {
            "id": "7cdb9210-1d59-43ba-94d1-ffbc2dc34c50",
            "name": "user_id",
            "fieldType": {
                "value": "String"
            },
            "required": true,
            "subfields": []
        },
        {
            "id": "cc2a9651-edbb-4864-b09b-af0914b9349b",
            "name": "timestamp",
            "fieldType": {
                "value": "DateTime"
            },
            "required": true,
            "subfields": []
        }
    ],
    "entities": [
        {
            "id": "5ed0f3c9-e3a1-417c-b0da-277d863d88f1",
            "name": "patron"
        }
    ]
}
"""
--- .//stellanow_sdk_python_demo/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python_demo/main.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
---

StellaNow SDK Python Demo
=========================

This script demonstrates the usage of the StellaNow SDK for Python, a powerful tool for real-time analytics.
The SDK enables developers to send event data (e.g., user details) to a StellaNow backend via a message queue and
MQTT sink, with support for secure authentication using Username and Password.

Key Features:
- Asynchronous event sending for non-blocking performance.
- Configurable message queue strategies (e.g., FIFO).
- MQTT-based sink with automatic reconnection and Username/Password authentication.
- Graceful shutdown handling for clean exits.

This demo sends two `UserDetailsMessage` events, simulating real-time user data collection, and showcases the SDK's
lifecycle: initialization, event sending, and shutdown.
"""

import asyncio
import sys

from loguru import logger
from messages.models.phone_number_model import PhoneNumberModel
from messages.user_details_message import UserDetailsMessage

from stellanow_sdk_python.configure_sdk import configure_dev_oidc_mqtt_fifo_sdk


async def main():
    """Main entry point for the StellaNow SDK demo."""
    # sdk = configure_local_nanomq_username_password_mqtt_lifo_sdk()
    sdk = configure_dev_oidc_mqtt_fifo_sdk()
    # sdk = configure_dev_username_password_mqtt_lifo_sdk()
    shutdown_event = asyncio.Event()  # Event to signal shutdown

    try:
        await sdk.start()
        for i in range(10):
            message = UserDetailsMessage(
                patron="12345", user_id=f"user_{i}", phone_number=PhoneNumberModel(country_code=44, number=753594 + i)
            )
            logger.info(f"Sending message {i + 1}...")
            await sdk.send_message(message)
            await asyncio.sleep(2)
        logger.info("Initial messages sent. Keeping SDK alive...")
        await shutdown_event.wait()  # Wait indefinitely until shutdown

    except KeyboardInterrupt:
        logger.warning("Received Ctrl+C, shutting down gracefully...")
        shutdown_event.set()  # Signal shutdown
        await sdk.stop()
    except Exception as e:
        logger.error(f"Unexpected error occurred: {e}")
        await sdk.stop()
        sys.exit(1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except ValueError as e:
        logger.error(f"Failed to start demo due to configuration error: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("Program interrupted by user, exiting cleanly.")
    except Exception as e:
        logger.exception(f"Program terminated with unexpected error: {e}")
        sys.exit(1)

--- .//tests/test_stellanow_wrapper.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import json
import pytest
import uuid

from datetime import datetime
from pydantic import Field
from typing import Dict

from stellanow_sdk_python.messages.base import StellaNowBaseModel
from stellanow_sdk_python.messages.message import Entity, StellaNowMessageBase, StellaNowMessageWrapper, Metadata
from stellanow_sdk_python.messages.event import StellaNowEventWrapper, EventKey


@pytest.fixture
def organization_id() -> str:
    """Fixture providing a sample organization ID."""
    return "9dbc5cc1-8c36-463e-893c-b08713868e97"


@pytest.fixture
def project_id() -> str:
    """Fixture providing a sample project ID."""
    return "529360a9-e40c-4d93-b3d3-5ed9f76c0037"


@pytest.fixture
def test_message() -> StellaNowMessageBase:
    class PhoneNumber(StellaNowBaseModel):
        number: int = Field(..., serialization_alias="number")
        country_code: int = Field(..., serialization_alias="country_code")

    class TestMessage(StellaNowMessageBase):
        phone_number: PhoneNumber = Field(..., serialization_alias="phone_number")
        user_id: str = Field(..., serialization_alias="user_id")

    return TestMessage(
        phone_number=PhoneNumber(country_code=48, number=700000),
        user_id="user_98888",
        event_name="test_event",
        entities=[Entity(entity_type_definition_id="test", entity_id="test_id")]
    )


@pytest.fixture
def message_wrapper(test_message: StellaNowMessageBase) -> StellaNowMessageWrapper:
    """Fixture providing a StellaNowMessageWrapper instance."""
    return StellaNowMessageWrapper.create(test_message)


def test_stellanow_message_wrapper_create(test_message: StellaNowMessageBase):
    """Test the create method of StellaNowMessageWrapper."""
    wrapped_message = StellaNowMessageWrapper.create(test_message)

    # Validate instance type
    assert isinstance(wrapped_message, StellaNowMessageWrapper), "Must return a StellaNowMessageWrapper instance"

    # Validate metadata
    metadata = wrapped_message.metadata
    assert isinstance(metadata, Metadata), "Metadata must be a Metadata instance"
    assert isinstance(metadata.message_id, str), "message_id must be a string"
    try:
        uuid.UUID(metadata.message_id, version=4)
    except ValueError:
        pytest.fail("message_id must be a valid UUID v4")
    assert isinstance(metadata.message_origin_date_utc, datetime), "message_origin_date_utc must be a datetime"
    assert metadata.event_type_definition_id == "test_event", "Event type mismatch"
    assert metadata.entity_type_ids == test_message.entities, "Entities mismatch"

    # Validate payload
    payload_dict = json.loads(wrapped_message.payload)
    expected_payload = {
        "phone_number": {"country_code": 48, "number": 700000},
        "user_id": "user_98888",
    }
    assert payload_dict == expected_payload, f"Payload mismatch. Expected {expected_payload}, got {payload_dict}"

    # Validate message_id property
    assert wrapped_message.message_id == metadata.message_id, "message_id property must match metadata.message_id"


def test_stellanow_message_wrapper_create_raw():
    """Test the create_raw method of StellaNowMessageWrapper."""
    entities = [Entity(entity_type_definition_id="test", entity_id="test_id")]
    message_json = json.dumps({"test": "data"})
    wrapped_message = StellaNowMessageWrapper.create_raw(
        event_type_definition_id="test_event",
        entity_types=entities,
        message_json=message_json
    )

    # Validate instance type
    assert isinstance(wrapped_message, StellaNowMessageWrapper), "Must return a StellaNowMessageWrapper instance"

    # Validate metadata
    metadata = wrapped_message.metadata
    assert isinstance(metadata.message_id, str), "message_id must be a string"
    assert isinstance(metadata.message_origin_date_utc, datetime), "message_origin_date_utc must be a datetime"
    assert metadata.event_type_definition_id == "test_event", "Event type mismatch"
    assert metadata.entity_type_ids == entities, "Entities mismatch"

    # Validate payload
    assert wrapped_message.payload == message_json, "Payload must match input"


def test_stellanow_event_wrapper_full_structure(
    message_wrapper: StellaNowMessageWrapper, organization_id: str, project_id: str
):
    """Test the full structure of StellaNowEventWrapper."""
    event_wrapper = StellaNowEventWrapper.create(
        message=message_wrapper,
        organization_id=organization_id,
        project_id=project_id
    )

    # Validate instance type
    assert isinstance(event_wrapper, StellaNowEventWrapper), "Must return a StellaNowEventWrapper instance"

    # Validate key
    assert isinstance(event_wrapper.key, EventKey), "Key must be an EventKey instance"
    expected_key = {
        "organizationId": organization_id,
        "projectId": project_id,
        "entityId": "test_id",
        "entityTypeDefinitionId": "test"
    }
    key_dict = event_wrapper.key.model_dump(by_alias=True)
    assert key_dict == expected_key, f"Key mismatch. Expected {expected_key}, got {key_dict}"

    # Validate value
    assert event_wrapper.value == message_wrapper, "Value must match the input message wrapper"

    # Validate message_id property
    assert event_wrapper.message_id == message_wrapper.message_id, "message_id must match the wrapped message's message_id"

    # Validate serialization
    serialized = event_wrapper.model_dump(by_alias=True)
    assert set(serialized.keys()) == {"key", "value"}, "Serialized output must contain only 'key' and 'value'"
    assert serialized["key"] == expected_key, "Serialized key mismatch"
    metadata = serialized["value"]["metadata"]
    assert metadata["messageOriginDateUTC"].endswith("Z"), "messageOriginDateUTC must end with 'Z'"
    # Add a check for the exact format
    assert "T" in metadata["messageOriginDateUTC"], "messageOriginDateUTC must contain 'T'"
    assert "+" not in metadata["messageOriginDateUTC"], "messageOriginDateUTC must not contain offset"
    try:
        datetime.fromisoformat(metadata["messageOriginDateUTC"].rstrip("Z"))
    except ValueError:
        pytest.fail("messageOriginDateUTC must be a valid ISO format datetime")


def test_stellanow_message_wrapper_serialization_exclusions(test_message: StellaNowMessageBase):
    """Test that private attributes are excluded from serialization."""
    wrapped_message = StellaNowMessageWrapper.create(test_message)
    serialized = wrapped_message.model_dump(by_alias=True)

    # Private attributes should not be in the serialized output
    assert "event_name" not in serialized, "Private attribute 'event_name' must be excluded"
    assert "entities" not in serialized, "Private attribute 'entities' must be excluded"

    # Validate expected fields
    assert set(serialized.keys()) == {"metadata", "payload"}, "Serialized output must contain only 'metadata' and 'payload'"


def test_stellanow_message_wrapper_optional_fields():
    """Test handling of optional fields in Metadata."""
    entities = [Entity(entity_type_definition_id="test", entity_id="test_id")]
    message_json = json.dumps({"test": "data"})
    wrapped_message = StellaNowMessageWrapper(
        metadata=Metadata(
            message_id=None,
            message_origin_date_utc=None,
            event_type_definition_id=None,
            entity_type_ids=entities
        ),
        payload=message_json
    )

    # Validate serialization
    serialized = wrapped_message.model_dump(by_alias=True)
    assert serialized["metadata"]["messageId"] is None, "messageId should be None"
    assert serialized["metadata"]["messageOriginDateUTC"] is None, "messageOriginDateUTC should be None"
    assert serialized["metadata"]["eventTypeDefinitionId"] is None, "eventTypeDefinitionId should be None"

    # Validate message_id property
    assert wrapped_message.message_id is None, "message_id should be None when metadata.message_id is None"

--- .//tests/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""
--- .//tests/test_stellanow_sdk.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import os
from unittest.mock import AsyncMock, MagicMock

import pytest

from stellanow_sdk_python.config.stellanow_config import project_info_from_env
from stellanow_sdk_python.message_queue.message_queue_strategy.fifo_message_queue_strategy import (
    FifoMessageQueueStrategy,
)
from stellanow_sdk_python.messages.message import Entity, StellaNowMessageBase
from stellanow_sdk_python.sdk import StellaNowSDK
from stellanow_sdk_python.sinks.i_stellanow_sink import IStellaNowSink

# Set environment variables for tests
os.environ["ORGANIZATION_ID"] = "1f40a798-edad-4b51-a41e-178c69491293"
os.environ["PROJECT_ID"] = "1c2825c5-6870-4543-9939-8dccbc7918c4"


@pytest.fixture
def mock_message():
    """Fixture providing a sample StellaNow message instance with EntityType-based entities.

    Returns:
        MockMessage: A configured instance of the MockMessage class.
    """
    class MockMessage(StellaNowMessageBase):
        user_id: str

        def to_json(self) -> dict:
            """Serialize the message fields to a dictionary, excluding entity-related fields."""
            return {"user_id": self.user_id}

    return MockMessage(
        event_name="test_event",
        entities=[Entity(entityTypeDefinitionId="test", entityId="test_id")],
        user_id="user_98888"
    )


@pytest.fixture
def mock_sink():
    """Fixture providing a mocked sink instance.

    Returns:
        MagicMock: A mock object simulating IStellaNowSink behavior with async methods.
    """
    mock = MagicMock(spec=IStellaNowSink)
    mock.connect = AsyncMock()
    mock.send_message = AsyncMock()
    mock.disconnect = AsyncMock()
    return mock


@pytest.fixture
def mock_queue_strategy():
    """Fixture providing a mocked queue strategy instance.

    Returns:
        MagicMock: A mock object simulating FifoMessageQueueStrategy behavior.
    """
    return MagicMock(spec=FifoMessageQueueStrategy)


@pytest.mark.asyncio
async def test_stellanow_sdk_start(mock_sink, mock_queue_strategy):
    """Test that StellaNowSDK initializes and starts correctly, connecting to the sink.

    This test verifies that the SDK starts its internal components, including the message queue
    and sink connection, using the provided project information and mocked dependencies.

    Args:
        mock_sink (MagicMock): Mocked sink instance.
        mock_queue_strategy (MagicMock): Mocked queue strategy instance.
    """
    project_info = project_info_from_env()
    sdk = StellaNowSDK(sink=mock_sink, queue_strategy=mock_queue_strategy, project_info=project_info)

    await sdk.start()

    # Verify sink connection (queue processing is internal to SDK)
    mock_sink.connect.assert_awaited_once()


@pytest.mark.asyncio
async def test_stellanow_sdk_stop(mock_sink, mock_queue_strategy):
    """Test that StellaNowSDK stops correctly, disconnecting from the sink and stopping the queue.

    This test verifies that the SDK performs a clean shutdown, stopping the message queue processing
    and disconnecting from the sink.

    Args:
        mock_sink (MagicMock): Mocked sink instance.
        mock_queue_strategy (MagicMock): Mocked queue strategy instance.
    """
    project_info = project_info_from_env()
    sdk = StellaNowSDK(sink=mock_sink, queue_strategy=mock_queue_strategy, project_info=project_info)
    await sdk.start()
    await sdk.stop()

    # Verify disconnection (queue stop is internal to SDK)
    mock_sink.disconnect.assert_awaited_once()

--- .//stellanow_sdk_python/messages/event.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""


from typing import Optional

from pydantic import Field

from stellanow_sdk_python.messages.base import StellaNowBaseModel
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper, Entity


class EventKey(StellaNowBaseModel):
    organization_id: str = Field(..., serialization_alias="organizationId")
    project_id: str = Field(..., serialization_alias="projectId")
    entity_id: str = Field(..., serialization_alias="entityId")
    entity_type_definition_id: str = Field(..., serialization_alias="entityTypeDefinitionId")


class StellaNowEventWrapper(StellaNowBaseModel):
    key: EventKey
    value: StellaNowMessageWrapper

    @property
    def message_id(self) -> Optional[str]:
        return self.value.message_id

    @classmethod
    def create(cls, message: StellaNowMessageWrapper, organization_id: str, project_id: str) -> "StellaNowEventWrapper":
        entity: Entity = message.primary_entity

        return cls(
            key=EventKey(
                organization_id=organization_id,
                project_id=project_id,
                entity_id=entity.entity_id,
                entity_type_definition_id=entity.entity_type_definition_id
            ),
            value=message
        )

--- .//stellanow_sdk_python/messages/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/messages/message.py ---
import json
import uuid
from datetime import datetime, UTC
from typing import List, Optional
from pydantic import Field

from stellanow_sdk_python.messages.base import StellaNowBaseModel


class Entity(StellaNowBaseModel):
    entity_type_definition_id: str = Field(..., serialization_alias="entityTypeDefinitionId")
    entity_id: str = Field(..., serialization_alias="entityId")


class Metadata(StellaNowBaseModel):
    message_id: Optional[str] = Field(None, serialization_alias="messageId")
    message_origin_date_utc: Optional[datetime] = Field(None, serialization_alias="messageOriginDateUTC")
    event_type_definition_id: Optional[str] = Field(None, serialization_alias="eventTypeDefinitionId")
    entity_type_ids: List[Entity] = Field(None, serialization_alias="entityTypeIds")

    @property
    def entities(self) -> List[Entity]:
        return self.entity_type_ids if self.entity_type_ids else []


class StellaNowMessageBase(StellaNowBaseModel):
    event_name: str = Field(exclude=True)
    entities: List[Entity] = Field(exclude=True)


class StellaNowMessageWrapper(StellaNowBaseModel):
    metadata: Metadata = Field(..., serialization_alias="metadata")
    payload: str = Field(..., serialization_alias="payload")

    @property
    def message_id(self) -> Optional[str]:
        return self.metadata.message_id if self.metadata and self.metadata.message_id else None

    @property
    def primary_entity(self) -> Entity:
         return self.metadata.entities[0]

    @classmethod
    def create(cls, message: StellaNowMessageBase) -> "StellaNowMessageWrapper":
        return cls.create_raw(
            event_type_definition_id=message.event_name,
            entity_types=message.entities,
            message_json=json.dumps(message.model_dump(by_alias=True))
        )

    @classmethod
    def create_raw(cls, event_type_definition_id: str, entity_types: List[Entity], message_json: str) -> "StellaNowMessageWrapper":
        return StellaNowMessageWrapper(
            metadata=Metadata(
                message_id=str(uuid.uuid4()),
                message_origin_date_utc=datetime.now(UTC) ,
                event_type_definition_id=event_type_definition_id,
                entity_type_ids=entity_types,
            ),
            payload=message_json
        )
--- .//stellanow_sdk_python/messages/base.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from datetime import datetime, date
from pydantic import BaseModel, ConfigDict, model_serializer


class StellaNowBaseModel(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
        ser_json_timedelta="iso8601",
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, default_serializer):
        data = default_serializer(self)

        def convert_fields(obj):
            if isinstance(obj, dict):
                return {k: convert_fields(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [convert_fields(item) for item in obj]
            elif isinstance(obj, datetime):
                return obj.strftime("%Y-%m-%dT%H:%M:%S.%f") + "Z"
            elif isinstance(obj, date):
                return obj.isoformat()
            return obj

        return convert_fields(data)

--- .//stellanow_sdk_python/sdk.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
---

StellaNow SDK Python Demo
=========================

This script demonstrates the usage of the StellaNow SDK for Python, a powerful tool for real-time analytics.
The SDK enables developers to send event data (e.g., user details) to a StellaNow backend via a message queue and
MQTT sink, with support for secure authentication using OpenID Connect (OIDC).

Key Features:
- Asynchronous event sending for non-blocking performance.
- Configurable message queue strategies (e.g., FIFO).
- MQTT-based sink with automatic reconnection and OIDC authentication.
- Graceful shutdown handling for clean exits.

This demo sends two `UserDetailsMessage` events, simulating real-time user data collection, and showcases the SDK's
lifecycle: initialization, event sending, and shutdown.
"""

import time
from typing import Optional

from loguru import logger

from stellanow_sdk_python.config.stellanow_config import StellaProjectInfo
from stellanow_sdk_python.message_queue.message_queue import StellaNowMessageQueue
from stellanow_sdk_python.message_queue.message_queue_strategy.i_message_queue_strategy import IMessageQueueStrategy
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper, StellaNowMessageBase
from stellanow_sdk_python.sinks.i_stellanow_sink import IStellaNowSink


class StellaNowSDK:
    def __init__(self, project_info: StellaProjectInfo, sink: IStellaNowSink, queue_strategy: IMessageQueueStrategy):
        """Initialize the SDK with project info, sink, and queue strategy."""
        self.project_info = project_info
        self.sink = sink
        self.message_queue = StellaNowMessageQueue(strategy=queue_strategy, sink=sink)

    async def start(self) -> None:
        """
        Starts the SDK and connects to the sink.
        """
        await self.sink.connect()  # Blocks until connected
        self.message_queue.start_processing()
        logger.info("SDK started successfully")

    async def send_message(self, message: StellaNowMessageBase) -> None:
        """
        Sends a message through the sink.
        :param message: The message to send.
        """
        wrapped_message = StellaNowMessageWrapper.create(
            message=message,
            organization_id=self.project_info.organization_id,
            project_id=self.project_info.project_id,
        )
        self.message_queue.enqueue(wrapped_message)

    def wait_for_queue_to_empty(self, timeout: Optional[float] = None) -> bool:
        """
        Waits for the message queue to be empty before proceeding.
        :param timeout: Maximum time to wait (in seconds). If None, waits indefinitely.
        :return: True if the queue is empty, False if timeout is reached and queue is not empty.
        """
        start_time = time.time()
        while not self.message_queue.is_empty():
            if timeout is not None and (time.time() - start_time) > timeout:
                logger.warning("Timeout reached while waiting for the message queue to empty.")
                return False
            time.sleep(0.1)
        logger.info("Message queue is empty.")
        return True

    async def stop(self) -> None:
        """Stops the SDK after ensuring the message queue is empty."""
        self.wait_for_queue_to_empty(timeout=10)
        await self.message_queue.stop_processing(timeout=5.0)
        await self.sink.disconnect()
        logger.info("SDK stopped successfully")

--- .//stellanow_sdk_python/config/stellanow_auth_credentials.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import os
from enum import Enum
from typing import Dict, Optional

from pydantic import BaseModel
from typing_extensions import TypedDict

DEFAULT_OIDC_CLIENT_ID = "event-ingestor"


class AuthStrategyTypes(Enum):
    OIDC = "oidc"
    USERNAME_PASS = "username_password"
    NO_AUTH = "none"


class CredentialFieldMapping(TypedDict):
    """Defines how env vars map to credential fields and whether they're required."""

    env_var: str
    field: str
    required: bool


# Define config outside the class to avoid Pydantic interference
STRATEGY_CONFIG: Dict[str, list[CredentialFieldMapping]] = {
    "oidc": [
        {"env_var": "OIDC_USERNAME", "field": "username", "required": True},
        {"env_var": "OIDC_PASSWORD", "field": "password", "required": True},
        {"env_var": "OIDC_CLIENT_ID", "field": "client_id", "required": False},
    ],
    "username_password": [
        {"env_var": "MQTT_USERNAME", "field": "username", "required": True},
        {"env_var": "MQTT_PASSWORD", "field": "password", "required": True},
    ],
    "none": [],
}


class StellaNowCredentials(BaseModel):
    username: Optional[str] = None
    password: Optional[str] = None
    client_id: Optional[str] = DEFAULT_OIDC_CLIENT_ID

    def is_valid(self, auth_strategy: str) -> bool:
        """Validate credentials for the given auth strategy."""
        config = STRATEGY_CONFIG.get(auth_strategy, [])
        return all(getattr(self, mapping["field"]) is not None for mapping in config if mapping["required"])

    @classmethod
    def from_env(cls, auth_strategy: str) -> "StellaNowCredentials":
        """Construct credentials from environment variables based on auth strategy."""
        config = STRATEGY_CONFIG.get(auth_strategy)
        if config is None:
            raise ValueError(f"Unsupported auth strategy: {auth_strategy}")

        env_values = {mapping["env_var"]: os.getenv(mapping["env_var"]) for mapping in config}
        missing_vars = [
            mapping["env_var"] for mapping in config if mapping["required"] and not env_values[mapping["env_var"]]
        ]
        if missing_vars:
            raise ValueError(f"Missing required env vars for '{auth_strategy}': {', '.join(missing_vars)}")

        field_defaults = {field_name: field.default for field_name, field in cls.model_fields.items()}
        kwargs = {
            mapping["field"]: (
                env_values[mapping["env_var"]]
                if env_values[mapping["env_var"]] is not None
                else field_defaults[mapping["field"]]
            )
            for mapping in config
        }
        instance = cls(**kwargs)

        if not instance.is_valid(auth_strategy):
            raise ValueError(f"Invalid credentials for '{auth_strategy}' after env var mapping")

        return instance

    @staticmethod
    def get_required_env_vars(auth_strategy: str) -> list[str]:
        """Return required environment variables for the given auth strategy."""
        config = STRATEGY_CONFIG.get(auth_strategy, [])
        return [mapping["env_var"] for mapping in config if mapping["required"]]


# Backward compatibility
credentials_from_env = StellaNowCredentials.from_env

--- .//stellanow_sdk_python/config/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/config/read_env.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import os
from typing import Optional

from loguru import logger


def read_env(name: str, missing: Optional[str] = None) -> str:
    """
    Read an environment variable, raising an error if not found and no fallback is provided.

    Args:
        name (str): The name of the environment variable.
        missing (Optional[str]): The fallback value if the variable is not set.

    Returns:
        str: The value of the environment variable or the fallback.

    Raises:
        ValueError: If the variable is not set and no fallback is provided.
    """
    value = os.getenv(name, missing)
    if value is None:
        logger.error(f"Required environment variable '{name}' is not set")
        raise ValueError(f"Required environment variable '{name}' is not set")
    return value

--- .//stellanow_sdk_python/config/stellanow_config.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from stellanow_sdk_python.config.read_env import read_env


class StellaProjectInfo:
    """Holds organization and project identifiers for the StellaNow SDK."""

    def __init__(self, organization_id: str, project_id: str):
        if not organization_id or not project_id:
            raise ValueError("organization_id and project_id must be non-empty strings")
        self.organization_id = organization_id
        self.project_id = project_id


def project_info_from_env() -> StellaProjectInfo:
    """Create a StellaProjectInfo instance from environment variables."""
    return StellaProjectInfo(organization_id=read_env("ORGANIZATION_ID"), project_id=read_env("PROJECT_ID"))

--- .//stellanow_sdk_python/config/eniviroment_config/stellanow_env_config.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from typing import Optional, Protocol

from stellanow_sdk_python.sinks.mqtt.utils.mqtt_url_parser import MqttUrlConfig, parse_mqtt_url


class StellaNowEnvironmentConfig(Protocol):
    mqtt_url_config: MqttUrlConfig
    api_base_url: Optional[str] = None

    @property
    def authority(self) -> str:
        pass


class _StellaNowEnvironmentConfigImpl:
    def __init__(self, mqtt_url: str, api_base_url: Optional[str] = None):
        self.mqtt_url_config = parse_mqtt_url(mqtt_url)
        self.api_base_url = api_base_url

    @property
    def authority(self) -> str:
        return f"{self.api_base_url}/auth/"


class EnvConfig:
    """Factory for creating environment configurations."""

    @staticmethod
    def stellanow_prod() -> StellaNowEnvironmentConfig:
        """Configuration for the StellaNow production environment."""
        return _StellaNowEnvironmentConfigImpl(
            mqtt_url="wss://ingestor.prod.stella.cloud:8083",
            api_base_url="https://api.prod.stella.cloud",
        )

    @staticmethod
    def stellanow_dev() -> StellaNowEnvironmentConfig:
        """Configuration for the StellaNow dev environment."""
        return _StellaNowEnvironmentConfigImpl(
            mqtt_url="wss://ingestor.dev.stella.cloud:8083",
            api_base_url="https://api.dev.stella.cloud",
        )

    @staticmethod
    def nanomq_local() -> StellaNowEnvironmentConfig:
        """Configuration for the NanoMq local environment."""
        return _StellaNowEnvironmentConfigImpl(mqtt_url="mqtt-tcp://localhost:1883")

    @staticmethod
    def create_custom_env(api_base_url: str, mqtt_broker_url: str) -> StellaNowEnvironmentConfig:
        """Create a custom environment configuration."""
        return _StellaNowEnvironmentConfigImpl(api_base_url=api_base_url, mqtt_url=mqtt_broker_url)

--- .//stellanow_sdk_python/config/eniviroment_config/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/sinks/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/sinks/i_stellanow_sink.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from abc import ABC, abstractmethod

from stellanow_sdk_python.messages.message import StellaNowMessageWrapper


class IStellaNowSink(ABC):
    """
    Defines the contract for a Sink in StellaNow.
    """

    @abstractmethod
    async def connect(self) -> None:
        """
        Connects to the sink (e.g., MQTT broker, Kafka).
        """

    @abstractmethod
    async def disconnect(self) -> None:
        """
        Disconnects from the sink.
        """

    @abstractmethod
    async def send_message(self, message: StellaNowMessageWrapper) -> None:
        """
        Sends a message to the sink.
        :param message: The message to send.
        """

    @abstractmethod
    def is_connected(self) -> bool:
        """
        Checks if the sink is connected.
        :return: True if connected; otherwise, False.
        """

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/no_auth_mqtt_auth_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import paho.mqtt.client as mqtt
from loguru import logger

from stellanow_sdk_python.sinks.mqtt.auth_strategy.i_mqtt_auth_strategy import IMqttAuthStrategy


class NoAuthMqttAuthStrategy(IMqttAuthStrategy):
    """No authentication strategy for MQTT connections."""

    async def authenticate(self, client: mqtt.Client) -> None:
        logger.info("Using NoAuth strategy for MQTT connection.")

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/user_pass_auth_mqtt_auth_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import paho.mqtt.client as mqtt
from loguru import logger

from stellanow_sdk_python.config.stellanow_auth_credentials import StellaNowCredentials
from stellanow_sdk_python.sinks.mqtt.auth_strategy.i_mqtt_auth_strategy import IMqttAuthStrategy


class UserPassAuthMqttAuthStrategy(IMqttAuthStrategy):
    """Username/password authentication strategy for MQTT connections."""

    def __init__(self, credentials: StellaNowCredentials):
        self.credentials = credentials

    async def authenticate(self, client: mqtt.Client) -> None:
        logger.info("Authenticating MQTT client using username/password.")
        try:
            client.username_pw_set(self.credentials.username, self.credentials.password)
        except Exception as e:
            logger.error(f"Username/password authentication failed: {e}")
            raise Exception("Failed to authenticate MQTT client using username/password.")

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/i_mqtt_auth_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from abc import ABC, abstractmethod

import paho.mqtt.client as mqtt


class IMqttAuthStrategy(ABC):
    """
    Defines the config for an MQTT authentication strategy.
    """

    @abstractmethod
    async def authenticate(self, client: mqtt.Client) -> None:
        """
        Authenticates the MQTT client.
        :param client: The MQTT client to authenticate.
        """

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/auth_factory.py ---
"""
Factory for creating MQTT authentication strategies.
"""

from loguru import logger

from stellanow_sdk_python.config.eniviroment_config.stellanow_env_config import StellaNowEnvironmentConfig
from stellanow_sdk_python.config.stellanow_auth_credentials import AuthStrategyTypes, StellaNowCredentials
from stellanow_sdk_python.config.stellanow_config import StellaProjectInfo
from stellanow_sdk_python.sinks.mqtt.auth_strategy.i_mqtt_auth_strategy import IMqttAuthStrategy
from stellanow_sdk_python.sinks.mqtt.auth_strategy.no_auth_mqtt_auth_strategy import NoAuthMqttAuthStrategy
from stellanow_sdk_python.sinks.mqtt.auth_strategy.oidc_mqtt_auth_strategy import OidcMqttAuthStrategy
from stellanow_sdk_python.sinks.mqtt.auth_strategy.user_pass_auth_mqtt_auth_strategy import UserPassAuthMqttAuthStrategy


def create_auth_strategy(
    auth_strategy_type: str,
    project_info: StellaProjectInfo,
    credentials: StellaNowCredentials,
    env_config: StellaNowEnvironmentConfig,
) -> IMqttAuthStrategy:
    """
    Create an authentication strategy based on the specified type.

    Args:
        auth_strategy_type (str): The type of authentication ("oidc", "username_password", "none").
        project_info (StellaProjectInfo): Project information including organization_id.
        credentials (StellaNowCredentials): The credentials object containing auth details.
        env_config (StellaNowEnvironmentConfig): The environment configuration.

    Returns:
        IMqttAuthStrategy: The instantiated authentication strategy.

    Raises:
        ValueError: If the auth_type is unsupported or required credentials are missing.
    """

    if not credentials.is_valid(auth_strategy_type):
        raise ValueError(f"Invalid or missing credentials for '{auth_strategy_type}'")

    logger.info(f"Creating auth strategy: {auth_strategy_type}")
    if auth_strategy_type == AuthStrategyTypes.OIDC.value:
        return OidcMqttAuthStrategy(project_info, credentials, env_config)
    elif auth_strategy_type == AuthStrategyTypes.USERNAME_PASS.value:
        return UserPassAuthMqttAuthStrategy(credentials)
    elif auth_strategy_type == AuthStrategyTypes.NO_AUTH.value:
        return NoAuthMqttAuthStrategy()
    else:
        raise ValueError(f"Unknown auth strategy type: {auth_strategy_type}")

--- .//stellanow_sdk_python/sinks/mqtt/auth_strategy/oidc_mqtt_auth_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import paho.mqtt.client as mqtt
from loguru import logger

from stellanow_sdk_python.authentication.auth_service import StellaNowAuthenticationService
from stellanow_sdk_python.config.eniviroment_config.stellanow_env_config import StellaNowEnvironmentConfig
from stellanow_sdk_python.config.stellanow_auth_credentials import StellaNowCredentials
from stellanow_sdk_python.config.stellanow_config import StellaProjectInfo
from stellanow_sdk_python.sinks.mqtt.auth_strategy.i_mqtt_auth_strategy import IMqttAuthStrategy


class OidcMqttAuthStrategy(IMqttAuthStrategy):
    """Authentication strategy using OpenID Connect (OIDC)."""

    def __init__(
        self, project_info: StellaProjectInfo, credentials: StellaNowCredentials, env_config: StellaNowEnvironmentConfig
    ) -> None:
        self.project_info = project_info
        self.credentials = credentials
        self.env_config = env_config
        self.auth_service = StellaNowAuthenticationService(
            project_info=self.project_info,
            credentials=self.credentials,
            env_config=self.env_config,
        )

    async def authenticate(self, client: mqtt.Client) -> None:
        """
        Authenticates the MQTT client using OIDC.
        """
        logger.info("Authenticating MQTT client using OIDC.")
        try:
            access_token = await self.auth_service.get_access_token()
            client.username_pw_set(access_token, password=None)
        except Exception as e:
            logger.error(f"OIDC authentication failed: {e}")
            raise Exception("Failed to authenticate MQTT client using OIDC.")

--- .//stellanow_sdk_python/sinks/mqtt/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/sinks/mqtt/utils/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/sinks/mqtt/utils/mqtt_url_parser.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from typing import Literal
from urllib.parse import urlparse


class MqttUrlConfig:
    def __init__(
        self, scheme: str, hostname: str, port: int, transport: Literal["tcp", "websockets", "unix"], use_tls: bool
    ):
        self.scheme = scheme
        self.hostname = hostname
        self.port = port
        self.transport = transport
        self.use_tls = use_tls


def parse_mqtt_url(url: str) -> MqttUrlConfig:
    """
    Parse an MQTT URL and return its configuration components.

    Args:
        url (str): The MQTT URL, e.g., 'mqtt-tcp://ingestor.dev.stella.cloud:1883',
                  'mqtts://broker:8883', 'ws://broker:80', or 'wss://broker:443'

    Returns:
        MqttUrlConfig: Object containing scheme, hostname, port, transport, and TLS flag.

    Raises:
        ValueError: If the URL is malformed or unsupported.
    """
    parsed = urlparse(url)

    # Validate scheme and determine transport/TLS
    scheme = parsed.scheme.lower()
    transport: Literal["tcp", "websockets"]
    use_tls: bool

    match scheme:
        case "mqtt" | "mqtt-tcp":
            transport = "tcp"
            use_tls = False
        case "mqtts":
            transport = "tcp"
            use_tls = True
        case "ws":
            transport = "websockets"
            use_tls = False
        case "wss":
            transport = "websockets"
            use_tls = True
        case _:
            raise ValueError(f"Unsupported MQTT scheme: {scheme}. Use 'mqtt', 'mqtt-tcp', 'mqtts', 'ws', or 'wss'.")

    # Extract hostname
    hostname = parsed.hostname
    if not hostname:
        raise ValueError("No hostname provided in MQTT URL.")

    # Extract port (default based on scheme if not provided)
    port = parsed.port
    if port is None:
        match scheme:
            case "mqtts":
                port = 8883
            case "wss":
                port = 443
            case "ws":
                port = 80
            case "mqtt" | "mqtt-tcp":
                port = 1883
            case _:
                raise ValueError(f"No default port defined for scheme: {scheme}")

    return MqttUrlConfig(scheme=scheme, hostname=hostname, port=port, transport=transport, use_tls=use_tls)

--- .//stellanow_sdk_python/sinks/mqtt/stellanow_mqtt_sink.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import asyncio
from typing import Any, Dict, Optional

import paho.mqtt.client as mqtt
from loguru import logger
from nanoid import generate

from stellanow_sdk_python.config.eniviroment_config.stellanow_env_config import StellaNowEnvironmentConfig
from stellanow_sdk_python.config.stellanow_config import StellaProjectInfo
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper
from stellanow_sdk_python.sinks.i_stellanow_sink import IStellaNowSink
from stellanow_sdk_python.sinks.mqtt.auth_strategy.i_mqtt_auth_strategy import IMqttAuthStrategy
from stellanow_sdk_python.sinks.mqtt.auth_strategy.oidc_mqtt_auth_strategy import OidcMqttAuthStrategy


class StellaNowMqttSink(IStellaNowSink):
    def __init__(
        self,
        auth_strategy: IMqttAuthStrategy,
        env_config: StellaNowEnvironmentConfig,
        project_info: StellaProjectInfo,
    ):
        self.auth_strategy = auth_strategy
        self.env_config = env_config
        self.project_info = project_info
        self.default_qos = 1
        self.client_id = f"StellaNowSDKPython_{generate(size=10)}"
        mqtt_config = env_config.mqtt_url_config

        self.client = mqtt.Client(
            callback_api_version=mqtt.CallbackAPIVersion.VERSION2,  # type: ignore[attr-defined]
            transport=mqtt_config.transport,
            client_id=self.client_id,
        )
        self.client.keepalive = 5
        if mqtt_config.use_tls:
            self.client.tls_set()

        self._is_connected_event = asyncio.Event()
        self._shutdown = False
        self._monitor_task: Optional[asyncio.Task[None]] = None

        self.client.on_connect = self.on_connect
        self.client.on_publish = self.on_publish
        self.client.on_disconnect = self.on_disconnect  # type: ignore[assignment]

        # Start the loop once during initialization
        self.client.loop_start()

        logger.info(f'SDK Client ID is "{self.client_id}"')

    async def connect(self) -> None:
        if self._shutdown:
            logger.info("Shutdown requested, skipping connection attempt.")
            return
        if not self._monitor_task:
            self._monitor_task = asyncio.create_task(self._connection_monitor())
            try:
                await asyncio.wait_for(self._is_connected_event.wait(), timeout=None)
                logger.info("Initial connection established")
            except asyncio.TimeoutError:
                logger.warning("Initial connection timed out after 30s, but monitor continues in background")

    async def disconnect(self) -> None:
        logger.info("Disconnecting from MQTT broker...")
        self._shutdown = True
        if self._monitor_task:
            self._monitor_task.cancel()
            try:
                await self._monitor_task
            except asyncio.CancelledError:
                pass
        if isinstance(self.auth_strategy, OidcMqttAuthStrategy):
            await self.auth_strategy.auth_service.stop_refresh_task()
        self.client.disconnect()
        self.client.loop_stop()
        self._is_connected_event.clear()

    async def send_message(self, message: StellaNowMessageWrapper) -> None:
        if not self.is_connected():
            logger.warning(
                f"Cannot send message {message.message_id}: MQTT sink is disconnected. Awaiting reconnection..."
            )
            raise Exception("MQTT sink is disconnected; connection monitor is attempting to reconnect.")
        mqtt_topic = f"in/{self.project_info.organization_id}"
        result = self.client.publish(mqtt_topic, message.model_dump_json(), qos=self.default_qos)
        logger.debug(f"Publish result: {result.rc}, MID: {result.mid}")
        if result.rc != mqtt.MQTT_ERR_SUCCESS:
            logger.error(f"Failed to send message {message.message_id}. Status: {result.rc}")
            raise Exception(f"Publish failed with status: {result.rc}")
        logger.debug(f"Message sent to with messageId: {message.message_id}")

    def is_connected(self) -> bool:
        if not self._is_connected_event.is_set():
            return False
        # Ensure the client is still functional
        return self.client.loop_misc() == mqtt.MQTT_ERR_SUCCESS

    def on_connect(
        self,
        client: mqtt.Client,  # noqa
        userdata: Any,  # noqa
        flags: Dict[str, Any],  # noqa
        reason_code: mqtt.ReasonCode,  # type: ignore # noqa
        properties: Optional[mqtt.Properties],  # type: ignore # noqa
    ) -> None:
        if reason_code == 0:
            logger.info("Connected to MQTT broker")
            self._is_connected_event.set()
        else:
            logger.error(f"Connection failed with code {reason_code}")
            self._is_connected_event.clear()

    def on_publish(  # noqa
        self,
        client: mqtt.Client,  # noqa
        userdata: Any,  # noqa
        mid: int,
        reason_code: mqtt.ReasonCode,  # type: ignore # noqa
        properties: Optional[mqtt.Properties],  # type: ignore # noqa
    ) -> None:
        logger.success(f"Message published with MID: {mid}")

    def on_disconnect(
        self,
        client: mqtt.Client,  # noqa
        userdata: Any,  # noqa
        flags: Dict[str, int],  # noqa
        rc: int,
        properties: Optional[Any] = None,  # noqa
    ) -> None:
        logger.warning(f"Disconnected from MQTT broker with reason: {rc}")
        self._is_connected_event.clear()

    async def _connection_monitor(self) -> None:
        logger.info("Started connection monitor")
        attempt = 0
        base_delay = 5
        max_delay = 60

        while not self._shutdown:
            logger.debug(f"Connection status: {self.is_connected()}")
            if not self.is_connected():
                attempt += 1
                try:
                    mqtt_config = self.env_config.mqtt_url_config
                    logger.info(
                        f"Attempting connection (Attempt {attempt}) to {mqtt_config.hostname}:{mqtt_config.port}"
                    )
                    await self.auth_strategy.authenticate(self.client)
                    self.client.connect_async(mqtt_config.hostname, mqtt_config.port, keepalive=5)
                    await asyncio.wait_for(self._is_connected_event.wait(), timeout=5.0)
                    logger.info("Connection successful")
                    attempt = 0
                except asyncio.TimeoutError:
                    logger.error(f"Connection attempt {attempt} timed out after 5 seconds")
                except Exception as e:
                    logger.error(f"Connection attempt {attempt} failed: {e}", exc_info=True)

                if not self.is_connected() and not self._shutdown:
                    delay = min(base_delay * (2 ** (attempt - 1)), max_delay)
                    logger.info(f"Retrying connection in {delay} seconds...")
                    await asyncio.sleep(delay)
            else:
                await asyncio.sleep(2.5)

        logger.info("Connection monitor stopped")

--- .//stellanow_sdk_python/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/configure_sdk.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import sys

from loguru import logger

from stellanow_sdk_python.config.eniviroment_config.stellanow_env_config import EnvConfig, StellaNowEnvironmentConfig
from stellanow_sdk_python.config.stellanow_auth_credentials import StellaNowCredentials
from stellanow_sdk_python.config.stellanow_config import project_info_from_env
from stellanow_sdk_python.message_queue.message_queue_strategy.fifo_message_queue_strategy import (
    FifoMessageQueueStrategy,
)
from stellanow_sdk_python.message_queue.message_queue_strategy.i_message_queue_strategy import MessageQueueType
from stellanow_sdk_python.message_queue.message_queue_strategy.lifo_message_queue_strategy import (
    LifoMessageQueueStrategy,
)
from stellanow_sdk_python.sdk import StellaNowSDK
from stellanow_sdk_python.sinks.mqtt.auth_strategy.auth_factory import create_auth_strategy
from stellanow_sdk_python.sinks.mqtt.stellanow_mqtt_sink import StellaNowMqttSink


def configure_sdk(
    auth_strategy_type: str,
    env_config: StellaNowEnvironmentConfig,
    queue_strategy_type: str = MessageQueueType.FIFO.value,
) -> StellaNowSDK:
    """
    Generic method to configure and return a StellaNowSDK instance.

    Args:
        auth_strategy_type (str): Authentication strategy ("oidc", "username_password", "none").
        env_config (StellaNowEnvironmentConfig): Environment configuration (e.g., from EnvConfig).
        queue_strategy_type (str, optional): Queue strategy ("fifo" and "lifo" currently supported). Defaults to "fifo".

    Returns:
        StellaNowSDK: A configured SDK instance.

    Raises:
        ValueError: If required environment variables are missing or invalid.
    """
    try:
        logger.remove()
        logger.add(sys.stderr, level="INFO")
        logger.info("Starting StellaNow SDK demo...")

        # Load project info
        project_info = project_info_from_env()
        logger.info(
            f"Loaded project info - Organization ID: {project_info.organization_id}, Project ID: {project_info.project_id}"
        )

        # Load credentials
        credentials = StellaNowCredentials.from_env(auth_strategy=auth_strategy_type)

        # Create auth strategy
        auth_strategy = create_auth_strategy(auth_strategy_type, project_info, credentials, env_config)

        # Initialize components
        queue_strategies = {
            MessageQueueType.FIFO.value: FifoMessageQueueStrategy,
            MessageQueueType.LIFO.value: LifoMessageQueueStrategy,
        }
        queue_strategy_class = queue_strategies.get(queue_strategy_type, FifoMessageQueueStrategy)
        queue_strategy = queue_strategy_class()
        mqtt_sink = StellaNowMqttSink(auth_strategy=auth_strategy, env_config=env_config, project_info=project_info)
        sdk = StellaNowSDK(project_info=project_info, sink=mqtt_sink, queue_strategy=queue_strategy)
        logger.info(f"SDK initialized with MQTT sink and {queue_strategy_type.upper()} queue strategy.")

        return sdk

    except ValueError as e:
        required_vars = ["ORGANIZATION_ID", "PROJECT_ID"] + StellaNowCredentials.get_required_env_vars(
            auth_strategy_type
        )
        logger.error(f"Configuration error: {e}")
        logger.info(
            f"Please set required environment variables for '{auth_strategy_type}' auth: {', '.join(required_vars)}"
        )
        raise


# Pre-defined configurations
def configure_dev_oidc_mqtt_fifo_sdk() -> StellaNowSDK:
    """Configure SDK for stellanow_dev env with OIDC auth, MQTT sink, and FIFO queue."""
    return configure_sdk(
        auth_strategy_type="oidc", env_config=EnvConfig.stellanow_dev(), queue_strategy_type=MessageQueueType.FIFO.value
    )


def configure_dev_username_password_mqtt_lifo_sdk() -> StellaNowSDK:
    """Configure SDK for stellanow_dev env with username/password auth, MQTT sink, and FIFO queue."""
    return configure_sdk(
        auth_strategy_type="username_password",
        env_config=EnvConfig.stellanow_dev(),
        queue_strategy_type=MessageQueueType.LIFO.value,
    )


def configure_local_nanomq_username_password_mqtt_fifo_sdk() -> StellaNowSDK:
    """Configure SDK for stellanow_dev env with username/password auth, MQTT sink, and FIFO queue."""
    return configure_sdk(
        auth_strategy_type="username_password",
        env_config=EnvConfig.nanomq_local(),
        queue_strategy_type=MessageQueueType.FIFO.value,
    )


def configure_local_nanomq_username_password_mqtt_lifo_sdk() -> StellaNowSDK:
    """Configure SDK for stellanow_dev env with username/password auth, MQTT sink, and FIFO queue."""
    return configure_sdk(
        auth_strategy_type="username_password",
        env_config=EnvConfig.nanomq_local(),
        queue_strategy_type=MessageQueueType.LIFO.value,
    )


def configure_prod_none_mqtt_fifo_sdk() -> StellaNowSDK:
    """Configure SDK for stellanow_prod env with no auth, MQTT sink, and FIFO queue."""
    return configure_sdk(
        auth_strategy_type="none",
        env_config=EnvConfig.stellanow_prod(),
        queue_strategy_type=MessageQueueType.FIFO.value,
    )


# Optional: Add more variants if you have LIFO or other strategies
# def configure_dev_oidc_mqtt_lifo_sdk() -> StellaNowSDK:
#     return configure_sdk(
#         auth_strategy_type="oidc",
#         env_config=EnvConfig.stellanow_dev(),
#         queue_strategy_type="lifo"
#     )

--- .//stellanow_sdk_python/message_queue/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/message_queue/message_queue_strategy/i_message_queue_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional

from stellanow_sdk_python.messages.message import StellaNowMessageWrapper


class MessageQueueType(Enum):
    FIFO = "fifo"
    LIFO = "lifo"


class IMessageQueueStrategy(ABC):
    """
    Defines the contract for a message message_queue strategy in StellaNow.
    """

    @abstractmethod
    def enqueue(self, message: StellaNowMessageWrapper) -> None:
        """
        Enqueues the specified message into the message_queue.
        :param message: The message in StellaNowMessageWrapper format to be queued.
        """

    @abstractmethod
    def try_dequeue(self) -> Optional[StellaNowMessageWrapper]:
        """
        Attempts to dequeue a message from the message_queue.
        :return: The dequeued message if successful; otherwise, None.
        """

    @abstractmethod
    def is_empty(self) -> bool:
        """
        Indicates whether the message_queue is currently empty.
        :return: True if the message_queue is empty; otherwise, False.
        """

    @abstractmethod
    def get_message_count(self) -> int:
        """
        Gets the number of messages currently in the message_queue.
        :return: The count of messages in the message_queue.
        """

--- .//stellanow_sdk_python/message_queue/message_queue_strategy/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

--- .//stellanow_sdk_python/message_queue/message_queue_strategy/lifo_message_queue_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import queue
import threading
from queue import LifoQueue
from typing import Optional

from stellanow_sdk_python.message_queue.message_queue_strategy.i_message_queue_strategy import IMessageQueueStrategy
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper


class LifoMessageQueueStrategy(IMessageQueueStrategy):
    """
    A last-in, first-out (LIFO) message_queue strategy for storing messages.
    """

    def __init__(self) -> None:
        self._queue: LifoQueue[StellaNowMessageWrapper] = queue.LifoQueue()
        self._lock = threading.Lock()

    def enqueue(self, message: StellaNowMessageWrapper) -> None:
        with self._lock:
            self._queue.put(message)

    def try_dequeue(self) -> Optional[StellaNowMessageWrapper]:
        with self._lock:
            if not self._queue.empty():
                return self._queue.get()
            return None

    def is_empty(self) -> bool:
        with self._lock:
            return self._queue.empty()

    def get_message_count(self) -> int:
        with self._lock:
            return self._queue.qsize()

--- .//stellanow_sdk_python/message_queue/message_queue_strategy/fifo_message_queue_strategy.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import queue
import threading
from queue import Queue
from typing import Optional

from stellanow_sdk_python.message_queue.message_queue_strategy.i_message_queue_strategy import IMessageQueueStrategy
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper


class FifoMessageQueueStrategy(IMessageQueueStrategy):
    """
    A first-in, first-out (FIFO) message_queue strategy for storing messages.
    """

    def __init__(self) -> None:
        self._queue: Queue[StellaNowMessageWrapper] = queue.Queue()
        self._lock = threading.Lock()

    def enqueue(self, message: StellaNowMessageWrapper) -> None:
        with self._lock:
            self._queue.put(message)

    def try_dequeue(self) -> Optional[StellaNowMessageWrapper]:
        with self._lock:
            if not self._queue.empty():
                return self._queue.get()
            return None

    def is_empty(self) -> bool:
        with self._lock:
            return self._queue.empty()

    def get_message_count(self) -> int:
        with self._lock:
            return self._queue.qsize()

--- .//stellanow_sdk_python/message_queue/message_queue.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import asyncio
from typing import Optional

from loguru import logger

from stellanow_sdk_python.message_queue.message_queue_strategy.i_message_queue_strategy import IMessageQueueStrategy
from stellanow_sdk_python.messages.message import StellaNowMessageWrapper
from stellanow_sdk_python.sinks.i_stellanow_sink import IStellaNowSink


class StellaNowMessageQueue:
    def __init__(self, strategy: IMessageQueueStrategy, sink: IStellaNowSink):
        """Initialize the message queue with a strategy and sink."""
        self.strategy = strategy
        self.sink = sink
        self.processing = False
        self._task: Optional[asyncio.Task[None]] = None

    def start_processing(self) -> None:
        """Start processing the queue as an asyncio task."""
        if not self.processing:
            self.processing = True
            loop = asyncio.get_running_loop()
            self._task = loop.create_task(self._process_queue())
            logger.info("Message queue processing started as asyncio task...")

    async def stop_processing(self, timeout: float = 5.0) -> None:
        """
        Stop the queue processing with an optional timeout.
        """
        if self.processing:
            self.processing = False
            if self._task:
                try:
                    await asyncio.wait_for(self._task, timeout=timeout)
                except asyncio.TimeoutError:
                    logger.warning(f"Queue processing did not stop within {timeout} seconds, forcing shutdown.")
                    self._task.cancel()
                    try:
                        await self._task
                    except asyncio.CancelledError:
                        pass
                finally:
                    self._task = None
            logger.info("Message queue processing stopped.")

    def enqueue(self, message: StellaNowMessageWrapper) -> None:
        """Add a message to the queue."""
        self.strategy.enqueue(message)
        logger.info(f"Message queued with messageId: {message.message_id}, Queue size: {self.get_message_count()}")

    async def _process_queue(self) -> None:
        """Process the queue asynchronously with connection handling."""
        logger.info(f"Starting queue processing with initial queue size: {self.get_message_count()}")
        while self.processing:
            if not self.sink.is_connected():
                logger.warning("Sink is disconnected, pausing queue processing...")
                await self._wait_for_connection()
                logger.info(f"Sink reconnected, resuming queue processing with queue size: {self.get_message_count()}")
            elif not self.strategy.is_empty():
                message = self.strategy.try_dequeue()
                if message:
                    logger.debug(f"Dequeued message {message.message_id}, Queue size: {self.get_message_count()}")
                    await self._send_message_to_sink(message)
            else:
                logger.debug("No messages in queue, waiting briefly...")
                await asyncio.sleep(0.1)

    async def _send_message_to_sink(self, message: StellaNowMessageWrapper) -> None:
        """Send a message to the sink with retry on failure."""
        try:
            await self.sink.send_message(message)
            logger.success(f"Message sent successfully with messageId: {message.message_id}")
        except Exception as e:
            logger.error(f"Failed to send message {message.message_id}: {e}")
            self.strategy.enqueue(message)
            logger.warning(f"Message {message.message_id} re-queued, Queue size: {self.get_message_count()}")
            await asyncio.sleep(1)

    async def _wait_for_connection(self) -> None:
        """Wait for the sink to reconnect."""
        while self.processing and not self.sink.is_connected():
            logger.debug("Waiting for sink to reconnect...")
            await asyncio.sleep(0.5)

    def is_empty(self) -> bool:
        """Check if the queue is empty."""
        return self.strategy.is_empty()

    def get_message_count(self) -> int:
        """Get the number of messages in the queue."""
        return self.strategy.get_message_count()

--- .//stellanow_sdk_python/authentication/auth_service.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

import asyncio
from datetime import datetime, timedelta
from typing import Any, Dict, Optional

from keycloak import KeycloakOpenID
from keycloak.exceptions import KeycloakError
from loguru import logger

from stellanow_sdk_python.config.eniviroment_config.stellanow_env_config import StellaNowEnvironmentConfig
from stellanow_sdk_python.config.stellanow_auth_credentials import StellaNowCredentials
from stellanow_sdk_python.config.stellanow_config import StellaProjectInfo


class StellaNowAuthenticationService:
    def __init__(
        self, project_info: StellaProjectInfo, credentials: StellaNowCredentials, env_config: StellaNowEnvironmentConfig
    ):
        if credentials.client_id is None:
            raise ValueError("Client ID is not set.")

        self.env_config = env_config
        self.keycloak_openid = KeycloakOpenID(
            server_url=env_config.authority,
            client_id=credentials.client_id,
            realm_name=project_info.organization_id,
            verify=True,
        )
        self.project_info = project_info
        self.credentials = credentials
        self.token_response: Optional[Dict[str, str]] = None
        self.token_expires: Optional[datetime] = None
        self.lock = asyncio.Lock()
        self._refresh_task: Optional[asyncio.Task[None]] = None

    async def start_refresh_task(self) -> None:
        """Start a background task to refresh the token periodically."""
        if self._refresh_task is None:
            self._refresh_task = asyncio.create_task(self._auto_refresh())

    async def stop_refresh_task(self) -> None:
        """Stop the token refresh task."""
        if self._refresh_task:
            self._refresh_task.cancel()
            try:
                await self._refresh_task
            except asyncio.CancelledError:
                pass
            self._refresh_task = None

    async def _auto_refresh(self) -> None:
        """Periodically refresh the token before it expires."""
        while True:
            if self.token_response and self.token_expires and not self._is_token_expired():
                expires_in = (self.token_expires - datetime.now()).total_seconds()  # Null check added
                await asyncio.sleep(max(expires_in - 30, 1))
            else:
                logger.debug("No valid token to refresh, attempting initial authentication.")
                await asyncio.sleep(1)
            try:
                await self.refresh_access_token()
            except Exception as e:
                logger.error(f"Failed to auto-refresh token: {e}")
                await asyncio.sleep(60)

    async def authenticate(self) -> str:
        """Authenticate and get the access token asynchronously."""
        async with self.lock:
            try:
                token_response = await self.keycloak_openid.a_token(
                    username=self.credentials.username, password=self.credentials.password  # type: ignore[arg-type]
                )
                if not isinstance(token_response, dict):
                    logger.error(
                        f"Unexpected response type from Keycloak: {type(token_response)}, value: {token_response}"
                    )
                    raise ValueError(f"Keycloak returned non-dict response: {token_response}")
                if "access_token" not in token_response:
                    logger.error(f"Token response missing 'access_token': {token_response}")
                    raise ValueError(f"Token response missing 'access_token': {token_response}")
                self.token_response = token_response
                self.token_expires = self._calculate_token_expires_time(self.token_response)
                logger.info("Authentication successful!")
                return self.token_response["access_token"]
            except KeycloakError as e:
                error_status = getattr(e, "response_code", "Unknown")
                error_message = (
                    getattr(e, "error_message", str(e)).splitlines()[0] if hasattr(e, "error_message") else str(e)[:100]
                )
                logger.error(f"Keycloak authentication failed: {error_status} - {error_message}")
                logger.debug(f"Full Keycloak error details: {e}")
                raise Exception(f"Failed to authenticate with Keycloak: {error_status} - {error_message}")
            except Exception as e:
                logger.error(f"Unexpected authentication error: {e}")
                raise Exception(f"Authentication failed: {e}")

    @staticmethod
    def _calculate_token_expires_time(token_response: Dict[str, Any]) -> datetime:
        token_expires_time = datetime.now() + timedelta(seconds=token_response.get("expires_in", 60))
        return token_expires_time - timedelta(seconds=10)

    def _is_token_expired(self) -> bool:
        if self.token_expires is None:
            return True  # Treat as expired if not set
        return datetime.now() >= self.token_expires

    async def get_access_token(self) -> str:
        if self.token_response is None or self._is_token_expired():
            logger.info("Token expired or missing. Re-authenticating...")
            return await self.authenticate()
        assert self.token_response is not None
        return self.token_response["access_token"]

    async def refresh_access_token(self) -> str:
        async with self.lock:
            if not self.token_response or "refresh_token" not in self.token_response:
                logger.warning("No valid refresh token available, falling back to authenticate.")
                return await self.authenticate()
            try:
                refresh_token = self.token_response["refresh_token"]
                logger.info("Refreshing access token...")
                self.token_response = await self.keycloak_openid.a_refresh_token(refresh_token)
                self.token_expires = self._calculate_token_expires_time(self.token_response)
                logger.info("Access token refreshed successfully.")
                assert self.token_response is not None
                return self.token_response["access_token"]
            except KeycloakError as e:
                logger.error(f"Failed to refresh access token: {e}")
                raise Exception("Failed to refresh access token")

--- .//stellanow_sdk_python/authentication/__init__.py ---
"""
Copyright (C) 2022-2025 Stella Technologies (UK) Limited.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

